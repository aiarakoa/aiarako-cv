import { createContext, useContext, useEffect, useRef, useState } from "react";

/**
 * Very small data shape to keep it obvious.
 * @typedef {{ articles: Array<any> }} CVData
 */

const CVContext = createContext(/** @type {{
  data: CVData|null,
  status: "idle"|"loading"|"error",
  error: Error|null,
  reload: () => Promise<void>
}} */(null));

export function CVProvider({ children })
{
  const [data, setData]                           = useState(/** @type {CVData|null} */(null));
  const [articles, setArticles]                   = useState(null);
  const [sections, setSections]                   = useState(null);
  const [articleIndex, setArticleIndex]           = useState(null);
  const [sectionsPerGroup, setSectionsPerGroup]   = useState(null);
  const [activeLink, setActiveLink]               = useState(null);
  const [presentationMode, setPresentationMode]   = useState(null);
  const [status, setStatus]                       = useState(/** @type {"idle"|"loading"|"error"} */("loading"));
  const [error, setError]                         = useState(/** @type {Error|null} */(null));

  // Guard against React 18 StrictMode double-effect in dev
  const hasLoadedRef = useRef(false);

  async function loadOnce()
  {
    setStatus("loading");
    setError(null);

    const url = `${process.env.PUBLIC_URL || ""}/data/cv.json`;

    try
    {
      const response = await fetch(url, { cache: "no-store" });
      if (!response.ok)
      {
        const body = await response.text().catch(() => "");
        throw new Error(`Fetch ${url} failed: ${response.status} ${response.statusText} — ${body.slice(0,200)}`);
      }
      /** @type {CVData} */
      const json          = await response.json();
      setData(json);
      const articlesMap   = new Map();
      const sectionsMap   = new Map();
      json.articles.forEach(article => {
        articlesMap.set(article.key, (({ key, ...art }) => art)(article));
        article.sections.forEach(section => sectionsMap.set(section.key, (({ key, ...sect }) => sect)(section)));
      });
      setArticles(articlesMap);
      setSections(sectionsMap);
      setArticleIndex(0);
      setStatus("idle");
      setActiveLink(null);
      setPresentationMode(window.matchMedia('(min-width: 1200px)').matches ? 'laptop' : 'mobile');
      setSectionsPerGroup(json.utilityBelt.sectionsPerGroup);

      console.groupCollapsed("[CV] Loaded");
      console.info("URL:", url);
      console.info("Articles:", Array.isArray(json.articles) ? json.articles.length : 0);
      console.groupEnd();
    }
    catch (err)
    {
      const e = err instanceof Error ? err : new Error(String(err));
      setError(e);
      setStatus("error");

      // Verba-timmy — say everything, don’t silently abort.
      console.group("[CV] Load error");
      console.error(e);
      console.info("URL:", url);
      console.info("Navigator:", navigator.userAgent);
      console.groupEnd();
    }
  }

  useEffect(() => {
    if (hasLoadedRef.current) return; // prevent dev double-load
    hasLoadedRef.current = true;

    let cancelled = false;
    (async () => {
      await loadOnce();
      if (cancelled) {
        // don’t set state if unmounted; we already guarded above anyway
        console.debug("[CV] Component unmounted before load completed.");
      }
    })();

    return () => { cancelled = true; };
    // empty deps → run once
  }, []);

  // Optional manual reload (e.g., a “Reload CV” button later)
  async function reload()
  {
    await loadOnce();
  }

  return (
    <CVContext.Provider value={{ data, articles, sections, articleIndex, setArticleIndex, sectionsPerGroup, setSectionsPerGroup, activeLink, setActiveLink, presentationMode, setPresentationMode, status, error, reload }}>
      {children}
    </CVContext.Provider>
  );
}

/** Read CV data anywhere under <CVProvider>. */
export function useCV()
{
  const ctx = useContext(CVContext);
  if (!ctx) throw new Error("useCV must be used within <CVProvider>");
  return ctx;
}